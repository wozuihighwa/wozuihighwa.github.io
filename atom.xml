<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-30T08:41:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/11/30/hello-world/"/>
    <id>http://yoursite.com/2016/11/30/hello-world/</id>
    <published>2016-11-30T08:41:27.000Z</published>
    <updated>2016-11-30T08:41:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次 OOM 排查</title>
    <link href="http://yoursite.com/2016/11/24/%E4%B8%80%E6%AC%A1%E5%9B%BE%E7%89%87_oom_%E6%8E%92%E6%9F%A5/"/>
    <id>http://yoursite.com/2016/11/24/一次图片_oom_排查/</id>
    <published>2016-11-24T12:24:21.000Z</published>
    <updated>2016-11-30T13:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p>
<h3 id="简述问题"><a href="#简述问题" class="headerlink" title="简述问题"></a>简述问题</h3><p>&emsp;&emsp;关于<code>java.lang.OutOfMemoryError</code>内存溢出这个问题肯定是不陌生，特别是在图片多的时候很容易出现。<br>在我的项目中使用的图片加载库是 Glide ，所有的图片显示都是通过这个库来加载的。但通过大量快速的滑动 RecyclerView ，发现还是会出现内存溢出的问题，并且问题出现在同一个地方，下面贴出 Log 栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1 dalvik.system.VMRuntime.newNonMovableArray(Native Method)</div><div class="line">2 android.graphics.Bitmap.nativeCreate(Native Method)</div><div class="line">3 android.graphics.Bitmap.createBitmap(Bitmap.java:879)</div><div class="line">4 android.graphics.Bitmap.createBitmap(Bitmap.java:856)</div><div class="line">5 android.graphics.Bitmap.createBitmap(Bitmap.java:823)</div><div class="line">6 com.makeramen.roundedimageview.RoundedDrawable.drawableToBitmap(RoundedDrawable.java:134)</div><div class="line">7 com.makeramen.roundedimageview.RoundedDrawable.fromDrawable(RoundedDrawable.java:117)</div><div class="line">8 com.makeramen.roundedimageview.RoundedImageView.setImageDrawable(RoundedImageView.java:221)</div><div class="line">9 com.bumptech.glide.request.target.GlideDrawableImageViewTarget.setResource(GlideDrawableImageViewTarget.java:80)</div><div class="line">10 com.bumptech.glide.request.target.GlideDrawableImageViewTarget.setResource(GlideDrawableImageViewTarget.java:12)</div><div class="line">11 com.bumptech.glide.request.target.ImageViewTarget.onResourceReady(ImageViewTarget.java:76)</div><div class="line">12 com.bumptech.glide.request.target.GlideDrawableImageViewTarget.onResourceReady(GlideDrawableImageViewTarget.java:66)</div><div class="line">13 com.bumptech.glide.request.target.GlideDrawableImageViewTarget.onResourceReady(GlideDrawableImageViewTarget.java:12)</div><div class="line">14 com.bumptech.glide.request.GenericRequest.onResourceReady(GenericRequest.java:525)</div><div class="line">15 com.bumptech.glide.request.GenericRequest.onResourceReady(GenericRequest.java:507)</div><div class="line">16 com.bumptech.glide.load.engine.EngineJob.handleResultOnMainThread(EngineJob.java:158)</div><div class="line">17 com.bumptech.glide.load.engine.EngineJob.access$100(EngineJob.java:22)</div><div class="line">18 com.bumptech.glide.load.engine.EngineJob$MainThreadCallback.handleMessage(EngineJob.java:202)</div><div class="line">19 android.os.Handler.dispatchMessage(Handler.java:98)</div><div class="line">20 android.os.Looper.loop(Looper.java:154)</div><div class="line">21 android.app.ActivityThread.main(ActivityThread.java:6077)</div><div class="line">22 java.lang.reflect.Method.invoke(Native Method)</div><div class="line">23 com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:865)</div><div class="line">24 com.android.internal.os.ZygoteInit.main(ZygoteInit.java:755)</div></pre></td></tr></table></figure>
<p>通过观察，发现问题出现在 com.makeramen.roundedimageview.RoundedImageView 这个 View 控件上。这个控件是一个用于显示圆角矩形图片的第三方库。</p>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>&emsp;&emsp;已知确实是用 Glide 进行图片加载的，Glide 加载到控件上的策略是先获取控件的宽高，然后在对原图片进行采样缩放处理（这部分是不会将 bitmap 直接加载到内存中的），并且加载过的图片 bitmap 被放入到 LruCache 和 DiskLruCache 缓存中（当然也可以自行配置 Glide 的缓存策略），因为 LruCache 内存缓存的策略是当缓存容量满了之后，继续加入的缓存的话，那么如此的话，不管怎么样，内存都不会溢出。那怎么又发生了图片的内存溢出呢？那么问题肯定是出在这个第三方库上，肯定有些操作涉及到了大量的内存增加，而当内存情况是：第三方库涉及内存 + Glide 管理的内存 + 其他必须内存 &gt; App 的最大内存，所以出现了 OOM。</p>
<h3 id="跟踪问题"><a href="#跟踪问题" class="headerlink" title="跟踪问题"></a>跟踪问题</h3><p>&emsp;&emsp;那么根据 Log 信息栈进行问题跟踪，先看 RoundedImageView.setImageDrawable 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageDrawable</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">    mResource = <span class="number">0</span>;</div><div class="line">    mDrawable = RoundedDrawable.fromDrawable(drawable);</div><div class="line">    updateDrawableAttrs();</div><div class="line">    <span class="keyword">super</span>.setImageDrawable(mDrawable);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看到覆盖了 ImageView 的 setImageDrawable 父类方法，代码很少，在最后调用了父类方法，所以在这之前做了一些处理，那就是做圆角的处理了。这里跟进到 RoundedDrawable.fromDrawable 这个方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">fromDrawable</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    Bitmap bm = drawableToBitmap(drawable);</div><div class="line">    ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>因为 Drawable 只是一个抽象概念，表示一个可绘制的东西，而 Bitmap 是真正直接进行图片操作的类，所以直接看与操作 bitmap 的 drawableToBitmap(Drawable drawable) 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">drawableToBitmap</span><span class="params">(Drawable drawable)</span> </span>&#123;</div><div class="line">    ...  </div><div class="line">    bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);</div><div class="line">    ...    </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看到，代码中有句调用 Bitmap 的 createBitmap 方法，这个方法最后会调用 native 方法以创建 bitmap 对象。到这里，就可以知道 RoundedImageView 这个库在图片填充进来时做了一次创建 bitmap 的内存操作。随着内存缓存的不断增加（滑动列表中很容易重现），当再次填充 drawable 到 roundedimageview 控件走一次 bitmap 创建操作时，需要分配内存，而内存上限接近峰值，并且 GC 回收不及时，就导致了 OOM。</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li>如果将这个控件使用在 Recyclerview、ListView 或循环使用的列表空间中，那么每一个 Item 都会进行一次 createBitmap 操作，这无疑会造成频繁的 GC，影响列表滚动的流畅度，当快速大量的滑动时，就会出现 OOM。</li>
<li>每次对 bitmap 做处理操作肯定是要有大量的内存操作的，不可能每次都去申请一块大内存吧？要是能够覆用这块大内存就好了，以后将每次对这块大内存的请求做成一个队列依次进行操作就好了。</li>
<li>在 Google 官方的性能优化视频中提到过”对象池”这个概念：对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。</li>
<li>恰好 Glide wiki 中有推荐一个开源库 Glide-transformations。这个库是配合 Glide 使用的库。Glide 提供了一个可以对图片填充前做变换的操作（圆角矩形图片，圆形图片，高斯模糊等等）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A class for performing an arbitrary transformation on a resource.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; The type of the resource being transformed.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformation</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//...略</span></div><div class="line">    <span class="function">Resource&lt;T&gt; <span class="title">transform</span><span class="params">(Resource&lt;T&gt; resource, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span></span>;</div><div class="line">    <span class="comment">//...略</span></div><div class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>反正 bitmap 的处理就那样，都要创建对象使用大量内存，那么不妨看看 Glide-transformations 这个库中的 RoundedCornersTransformation 类——圆角矩形处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundedCornersTransformation</span> <span class="keyword">implements</span> <span class="title">Transformation</span>&lt;<span class="title">Bitmap</span>&gt; </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">private</span> BitmapPool mBitmapPool;</div><div class="line">  ...</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">transform</span><span class="params">(Resource&lt;Bitmap&gt; resource, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span> </span>&#123;</div><div class="line">	...</div><div class="line">    Bitmap bitmap = mBitmapPool.get(width, height, Bitmap.Config.ARGB_8888);</div><div class="line">    <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">      bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">	<span class="keyword">return</span> BitmapResource.obtain(bitmap, mBitmapPool);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关处理操作的代码就省略掉了，留下了关键代码。可以看到，这个类使用了一个叫 BitmapPool 的接口，跟进这个接口，发现是 Glide 中提供的用于重用 bitmap 对象的对象池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * An interface for a pool that allows users to reuse &#123;<span class="doctag">@link</span> android.graphics.Bitmap&#125; objects.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BitmapPool</span> </span>&#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 BitmapPool 具体实现暂不探索，但由此可以想到 RoundedCornersTransformation 对于 bitmap 的操作先是从 BitmapPool 对象池冲获取已有的内存缓存（没有就先创建），以代替每次都去申请新的内存空间，避免了频繁的 GC，避免了因为内存突然的激增导致的 OOM。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>通过使用 Glide 的 Transformation 和 BitmapPool，可以避免频繁的申请新的内存空间，避免频繁的 GC（在列表空间中提高了滚动流畅度），也避免了因为内存突然激增而回收不及时导致的 OOM。</li>
<li>对于使用在图片上做处理或使用第三方库时，对 Bitmap 的操作要敏感（也是基于对 Bitmap 操作的熟悉程度），合理规划内存分配。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;简述问题&quot;&gt;&lt;a href=&quot;#简述问题&quot; class=&quot;headerlink&quot; title=&quot;简述问题&quot;&gt;&lt;/a&gt;简述问题&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;关于&lt;code&gt;java.lang.OutOfMemoryError&lt;/co
    
    </summary>
    
    
  </entry>
  
</feed>
